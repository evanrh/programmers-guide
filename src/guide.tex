% 12 pt font, maybe decide on a different font later
\documentclass[12pt, oneside, a4paper]{book}

% Package inclusions
\usepackage{indentfirst} % Indents first paragraph in a section
\usepackage{hyperref} % Hyperlinking and anchoring
\usepackage[dvipsnames]{xcolor} % Better color options
\usepackage[Bjornstrup]{fncychap} % Fancy chapter headers
\usepackage{csvsimple} % CSV to table handling
\usepackage{listings} % Sections for embedding formatted source code
\usepackage{xcolor-solarized} % Better Python highlighting
\usepackage{float} % Keep things in line

% MLA Citations
\usepackage[american]{babel}
\usepackage{csquotes}
\usepackage[
   backend=biber,
   style=ieee,
   sorting=none,
   natbib=true,
   hyperref=false
]{biblatex}

\addbibresource{refs.bib}

% Setup JavaScript listing style

\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with, let},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  sensitive=true
}

% Setup for Python listings

\lstset{
   language=Python,
   basicstyle=\small\sffamily,
   numbers=left,
   numberstyle=\tiny,
   frame=tb,
   tabsize=4,
   columns=fixed,
   showstringspaces=false,
   showtabs=false,
   keepspaces,
   commentstyle=\color{green},
   keywordstyle=\color{blue}
}

% Hyperlinking setup
\hypersetup{
   colorlinks = true,
   urlcolor = cyan,
   linkcolor = ForestGreen,
   pdftitle={An Intermediate Programmer's Guide to Developing Skills},
   citecolor = black
}

% TOC Setup
\setcounter{tocdepth}{1}
\setcounter{secnumdepth}{2}

% Front matter
\title{A Guide to Developing Skills for an Intermediate Programmer}
\date{\today}
\author{Evan Hastings}

\begin{document}
   \pagenumbering{gobble}
   \maketitle
   \newpage
   \pagenumbering{roman}
   \tableofcontents
   \lstlistoflistings
   \addcontentsline{toc}{chapter}{List of Code Listings}
   \listoftables
   \addcontentsline{toc}{chapter}{\listtablename}

   \chapter*{Preface}
   \addcontentsline{toc}{chapter}{Preface}
      Programming as an activity is both very engaging and rewarding.
      Once you have gained the initial knowledge of programming, learning where to go from there can be difficult.
      This guide's goal is to provide you with a meaningful way to continue developing your skills on your own.

      Each section addresses a separate concern or concentration a fledgling programmer might be interested in.
      That being said, each section is standalone and they can be read and completed in any order, but it would be beneficial to read the \hyperref[chap:general]{General} section before the others.

      All programming that you do can help you in any section, because the concepts are the same at their most basic.
      For example, the \hyperref[chap:challenge]{Challenging} section will teach you how to think more algorithmically, and once you understand algorithms, the knowledge can be applied to the other topics.

      Lastly, this book is intended to help further your development of skills relevant to programming.
      It should not be used to learn the basics of programming, and it will likely seem foreign if you have not done much programming before.

      Below are some concepts you should be familiar with before using this book\footnotemark.

      \footnotetext{
         A useful text for learning the prerequisite material is \href{https://beej.us/guide/bgc/}{Beej's Guide to C}.
         You need not read the entire text, only the chapters relevant to the subject matter listed.
      }
      % Prerequisite knowledge to using guide
      \begin{itemize}
         \item Data types (variable types)
         \item Compiled languages vs interpreted languages
         \item Pointers and arrays
      \end{itemize}

   \newpage
   \pagenumbering{arabic}

   \chapter{General Knowledge and Improvement}
   \label{chap:general}
      This chapter aims at helping you with programming in general.
      The examples and material here will help to provide a better foundational understanding of coding.

      \section{Paradigms}
         % Overview of language paradigms and some examples of what they look like
         Programming languages follow what are known as paradigms, which are the structure for how a language is written.
         All programming languages roughly fit into three paradigms: imperative, object-oriented, and functional \autocite{normarkOverviewFourMain}.

         \subsection{Imperative}
         Most programming languages offer an imperative approach, and you've most likely used one at some point.
         A few examples of imperative languages are: C, Python, and JavaScript.

         Imperative languages treat the input source code as a sequential set of instructions that the computer will run.
         They are also characteristic in that the program's state changes due to the passing of time \autocite{normarkOverviewFourMain}.
         Imperative programming is what most programmers learn first, because thinking of code as a set of instructions that operate on state is a simple concept to grasp.

         \subsection{Object-Oriented}
         Object-oriented languages are in major use today.
         Some examples of languages that use an object-oriented approach are: C++, Python, and Java.

         Object-oriented languages organize data and methods into 'objects' which are an encapsulation.
         Objects interact with each other through methods that they list publicly to each other, and they are organized in hierarchies of inheritance \autocite{normarkOverviewFourMain}.
         These restrictions on interaction and inheritance allow the programmer to hide away details from how the code actually works.
         As a result, the designer provides methods that perform actions with observable and reasonable side effects.

         \subsection{Functional}
         Functional languages see use, but they are far less used compared to the other two paradigms.
         Examples of functional languages include: Haskell, Lisp, and JavaScript\footnotemark.

         This paradigm treats code as a series of mathematical equations that are evaluated at run time.
         Functional languages treat data as immutable, so the program's state cannot be changed as in the other paradigms \autocite{normarkOverviewFourMain}.
         Functions are also treated like data, and they can be passed as arguments to other functions.

         This approach produces code that is very safe to use, but it can take a much longer amount of time to write.
         It also produces code that is thread-safe by nature, since the resulting program does not update state as it progresses.

         \footnotetext{
            Of these languages, only Haskell is purely functional.
            The other languages support functional styles, but they do not restrict the user into following them.
         }

         There are more paradigms than just these three, but these are the most commonly seen ones.
         Languages are also not restricted into only using one paradigm, and in fact, most support several.
         Python for instance, typically follows an imperative or object-oriented approach, but it also has support for functional styling.
         It also supports procedural programming \autocite{GeneralPythonFAQ}.

      \section{Language Use Cases}
         % Overview of when certain language are best
         While programming languages are typically designed to be used in a variety of situations, over time they start to develop a target domain.
         You can use a language in any manner you see fit, but they each do have strengths and weaknesses when used for different applications.
         It is useful to know what a language is good for, so that you can use the right tool for each job.
         So, what are some common use cases and languages that are useful for them?

         \subsection{Systems and Low Level}
         Systems require languages that can both operate at a low level and run quickly.
         According to Microsoft, systems differ from applications, because they are tasked with controlling the hardware and providing interfaces for higher level languages \autocite{microsoftPanelSystemsProgramming2014}.
         As a result, a standard library and operating system are not present at this level.

         \subsection{Data Science}
         The concerns of data science are that a language has good support for matrices and for statistical analysis.
         Historically, the languages that have been used are not as focused on speed as they are on flexibility, but speed is becoming a concern as larger projects get built to handle data science needs.

         Languages that are key to data science are:
         \begin{itemize}
            \item Python
            \item R
            \item SQL
            \item Julia
         \end{itemize} \autocite{MostPopularLanguages}

         Python and R are the most widely used, but they do not prioritize speed as a concern.
         Julia is a more recent language that aims to address this concern, while also keeping the same amount of flexibility as Python and R \autocite{MostPopularLanguages}.

         \subsection{Web}
         Web programming has much different concerns from other domains.
         On the web, software is much more focused on usability and scalability \autocite{siiaSoftwareServiceChanging2004}.
         As a result, preferred languages for the Web domain will allow for rapid prototyping, package integration, and object-oriented capabilities.
         Web programming also deals with a separate front-end, which is what the user sees, and backend, which is what the user does not see.
         This section covers useful backend languages.

         Popular languages in this domain include: PHP, Python, and C#.

         These languages are great for Web development, because they all share features that allow for efficient, rapid development.
         Each of them has an officially developed package management tool that allows for ease of access in including third-party code in a project.
         All three languages also have great frameworks for Web projects that allow for even easier development of good products.
         \subsection{Extra Considerations}
         Programming languages are often designed to be general purpose, and they don't necessarily have to be used as detailed above.
         They can be applied to realistically any domain that the user sees fit, but take care to keep in mind the main concerns a language's design addresses.
         For example, if you wanted to make a speedy web application, you might be inclined to write the application in C.
         While this is perfectly okay, the amount of time spent developing the application will be exponentially higher than if you had begun the project with a language like Ruby.
         The software you write may also not be portable if you took advantage of system level APIs while writing the code.
         
   \chapter{Practical Programming}
   \label{chap:practical}
      % Get some ideas from Al Sweisgart's 'Automate the Boring Stuff'
      In this chapter, you will be guided through programming in a useful manner.
      The examples used in this chapter will be useful for automating tasks at work or home.
      They also will focus on getting data from the Web quickly.
   \chapter{Challenging Yourself}
   \label{chap:challenge}
      % Programming challenges and things like Project Euler or LeetCode
      Many of the problems a programmer faces are already solved, and it is useful to know how to recognize and solve some of the simpler ones.
      That being said, the examples in this chapter will likely difficult if you have not seen them before, but once you have solved them, they will become trivial for you in the future.
      This chapter will also focus on taking functional approaches to the problems.
      Functional programming is much more difficult to think about than imperative styles, and typically a programmer who can write functional style code can translate it to imperative code if needed.

      \section{Math and Simple Algorithms}
         \subsection{Largest Prime Factor}
         % Project Euler #3
         Prime numbers are an idea that show up quite a bit in modern computing.
         They are the foundation of cryptography, and finding prime numbers with a computer can take a long time.
         That being said, this example will supply a solution to quickly solving for smaller prime numbers in the order of less than 1 million.

         \subsubsection{The Problem}
         Given a number \textit{n} find the sum of all prime numbers from [2,\textit{n}] in under a second.
         \textit{n} will be less than 1,000,000.

         \subsubsection{The Algorithm}
         The typical way to solve for primality of \textit{n} is to modulus it with every number preceding it and verify if any result produces 0.
         This is a very slow way to solve this problem, and in order to solve it more quickly, we can leverage an algorithm from an ancient Greek mathematician: the \textit{sieve of Eratosthenes}.

         % Include some kind of graphic here
         According to Sedgewick, the sieve works on an array of numbers that get marked if they are composite, and it starts at 2, working up until $\sqrt{n}$.
         Each number, \textit{i}, starting at \textit{$i^2$}, will be marked as composite, until the limit is reached.
         Then, \textit{i} will advance to the next unmarked number, and will continue until the limit.
         At the end, all unmarked numbers are prime \autocite{sedgewickAlgorithms1992}.

         See below, in Listing \ref{sieve} for an example of the sieve in Python.
         \lstinputlisting[
            language=Python,
            firstline=2,
            lastline=23,
            caption={A simple sieve that adds up the resulting primes},
         label=sieve]
         {examples/chapter3/sieve.py}

         The example in Listing \ref{sieve} uses an array of bools with the positions representing each number.
         A value of 'true' indicates that the number is prime, and each number is initially set to 'true'.
         Once this list is created, it is looped over starting from the first prime number, 2, until i reaches $\sqrt{n}$.
         At this point, on line 20, the indices are enumerated alongside the primalities, and the composites are filtered out.
         Then, the primes are summed and returned from the function.

         \subsection{Odd Fibonacci Numbers}
         % Free Code Camp Intermediate JS A&S 'Sum All Odd Fibonacci Numbers'
         This problem comes from FreeCodeCamp's \textit{Intermediate Algorithm Scripting} course, and it functions similarly to the last problem \autocite{freecodecampLearnIntermediateAlgorithm}.
         The structure requires us to slightly revise an existing algorithm to solve a different problem.

         \subsubsection{The Problem}
         ``Given a positive integer, \textit{num}, find the sum of all odd Fibonacci numbers that are less than or equal to \textit{num}.''

         \subsubsection{The Algorithm}
         This problem requires the programmer to use a subset of the Fibonacci sequence in order to find the result.
         A naïve solution would be to generate a list of all Fibonacci numbers less than \textit{num} and filter out the odd numbers.
         A better approach is to accumulate the odd numbers as you generate all Fibonacci numbers less than \textit{num}.
         The below example in Listings \ref{fibNums} shows an example of the second algorithm in Javascript.

         \lstinputlisting[
            language=JavaScript,
            caption={Summing Odd Fibonacci Numbers},
         label=fibNums]
         {examples/chapter3/oddFibNums.js}

         The Fibonacci sequence is a numerical sequence where each consecutive element is found by summing the previous two elements \autocite{parshallFibonacciSequence}.
         The first two elements are 1 and 1, respectively, so the sequence begins as such: 1,1,2,3,5,8\ldots.
         Listing \ref{fibNums} uses an iterative algorithm that accumulates the odd numbered Fibonacci numbers into \lstinline!result!.
         \lstinline!p! and \lstinline!q! represent the previous two members of the sequence.
         Doing so allows the work of summing the odd numbers to be done while generating the sequence itself.

   \chapter{Professional Development}
   \label{chap:prof_devel}
      % Ways to improve your programming at a professional level
      % Include example using an API
      Solid, effective programming can lead to a good career in the computing industry.
      Programming is a skill in high demand that can lead to many different high paying careers (see Table \ref*{table:jobs}).
      Learning to develop yourself professionally requires learning about the tools that are available to you, as well as learning programming.
      In this chapter, we will cover API usage with a fun, RESTful API, learning a new language, and some information on current technology.
      \begin{table}[H]
         \csvreader[
            respect all,
            tabular=|c|c|c|,
            table head=\hline \bfseries{Job} & \bfseries{Required Degree} & \bfseries{Median Salary} \\\hline,
            late after last line=\\\hline
         ]{salaries.csv}{}{
            \csvcoli & \csvcolii & \csvcoliii
         }
         \caption{
            Median salaries of jobs requiring programming skills in 2019, acquired from Malvik at Rasmussen \autocite{malvikProgrammingCareersCoding}.
         }
         \label{table:jobs}
      \end{table}

      \section{API Usage}
      APIs or 'Application Programming Interfaces' are publicly exposed methods for accessing someone else's system.
      REST, which stands for 'REpresentational State Transfer' is a design pattern that allows responses between a client and server to remain stateless and consistently defined \autocite{hallettPokeAPI}.
      The API being used for this chapter is called 'PokeAPI', and it is used to provide a programmatic interface to information regarding Pokémon.
      While not inherently useful on its own for our purposes, this API will help show you how many APIs across the web structure themselves.
      Knowledge of one RESTful API will lead to easier access to any others you come across while coding.

      \section{Current Technology and Practices}
      Software development has taken to a new domain in the past 20 years.
      Most applications now are being developed to run as web applications or 'software-as-a-service' (SAAS) in cloud based environments currently \autocite{WhatCloudComputing}.
      As a result of this shift, applications require a special set of considerations to made, so that they can scale and serve users properly.

      The typical guideline for this is known as the '12 Factor App\footnotemark,' which separates out the concerns of an application from its runtime environment \autocite{wigginsTwelveFactorApp2017}.
      Using this as a basis allows for a small, scalable application that can be deployed on almost any machine.
      Let's take a look at some of the most important tenets from the specification.
      \footnotetext{
         An HTML version of the 12 Factor App spec can be found at \url{https://12factor.net}.
      }


\newpage
\phantomsection
\printbibliography[title={Works Cited},heading=bibintoc]
\end{document}
