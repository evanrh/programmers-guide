% 12 pt font, maybe decide on a different font later
\documentclass[12pt, oneside, a4paper]{book}

% Package inclusions
\usepackage{indentfirst} % Indents first paragraph in a section
\usepackage{hyperref} % Hyperlinking and anchoring
\usepackage[dvipsnames]{xcolor} % Better color options
%\usepackage[Rejne]{fncychap} % Fancy chapter headers
\usepackage{csvsimple} % CSV-to-table handling
\usepackage{listings} % Sections for embedding formatted source code
\usepackage{xcolor-solarized} % Better Python highlighting
\usepackage{float} % Keep things in line
\usepackage{tocbibind} % Put TOC in TOC
\usepackage[toc,page]{appendix} % Better appendix titling

% IEEE Citations
\usepackage[american]{babel}
\usepackage{csquotes}
\usepackage[
   backend=biber,
   style=ieee,
   sorting=none,
   natbib=true,
   hyperref=false
]{biblatex}

\addbibresource{refs.bib}

% Setup JavaScript listing style

\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with, let},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  sensitive=true
}

% Setup for Python listings

\lstset{
   language=Python,
   basicstyle=\small\sffamily,
   numbers=left,
   numberstyle=\tiny,
   frame=tb,
   tabsize=4,
   columns=fixed,
   showstringspaces=false,
   showtabs=false,
   keepspaces,
   commentstyle=\color{green},
   keywordstyle=\color{blue}
}

% Variable for inserting Title where it is needed
\newcommand\titletext{A Guide to Developing Skills for an Intermediate Programmer}

% Hyperlinking setup
\hypersetup{
   colorlinks = true,
   urlcolor = cyan,
   linkcolor = ForestGreen,
   pdftitle=\titletext,
   citecolor = black
}

% TOC Setup
\setcounter{tocdepth}{1}
\setcounter{secnumdepth}{2}

% Front matter
\title{\titletext}
\date{\today}
\author{Evan Hastings}

\begin{document}
   \pagenumbering{gobble}
   \maketitle
   \newpage
   \pagenumbering{roman}
   \tableofcontents
   \lstlistoflistings
   \listoftables

   \chapter*{Preface}
   \addcontentsline{toc}{chapter}{Preface}
      Programming as an activity is both very engaging and rewarding.
      Once you have gained the initial knowledge of programming, learning where to go from there can be difficult.
      This guide's goal is to provide you with a meaningful way to continue developing your skills on your own.

      Each section addresses a separate concern or concentration an intermediate programmer might be interested in.
      That being said, each section is standalone and they can be read and completed in any order, but it would be beneficial to read the \hyperref[chap:general]{General} section before the others.

      Similar to other skills, the more you practice programming, the better you will become at it.
      The concepts also overlap with each other, so practice in one area will likely help with learning about another.
      For example, the \hyperref[chap:challenge]{Challenging} section will teach you how to think more algorithmically, and once you understand algorithms, the knowledge can be applied to the other focus areas to speed up your code..

      Lastly, this book is intended to help further your development of skills relevant to programming.
      It should not be used to learn the basics of programming, and it will likely seem foreign if you have not done much programming before.

      Below are some concepts you should be familiar with before using this book\footnotemark.
      If these concepts are unfamiliar to you, please refer to the \hyperref[chap:def]{Definitions} section for more information.

      \footnotetext{
         A useful text for learning the prerequisite material is \href{https://beej.us/guide/bgc/}{Beej's Guide to C}.
         You need not read the entire text, only the chapters relevant to the subject matter listed.
      }
      % Prerequisite knowledge to using guide
      \begin{itemize}
         \item Data types (variable types)
         \item Compiled languages vs interpreted languages
         \item Pointers and arrays
      \end{itemize}

      Lastly, almost all of the examples provided by this guide will be written in Python, as it produces very brief and readable source code.
      Please consult the appendix for 
   \newpage
   \pagenumbering{arabic}

   \chapter{General Knowledge and Improvement}
   \label{chap:general}
      This chapter aims at helping you with programming in general.
      The examples and material here will help familiarize you with the environment that you will be working in.

      \section{Paradigms}
         % Overview of language paradigms and some examples of what they look like
         Programming languages follow what are known as paradigms, which are the structure for how a language is written.
         All programming languages roughly fit into three paradigms: imperative, object-oriented, and functional \autocite{normarkOverviewFourMain}.
         Languages are also not restricted into only using one paradigm, and in fact, most support several.
         Python for instance, typically follows an imperative or object-oriented approach, but it also has support for functional styling \autocite{GeneralPythonFAQ}.

         \subsection{Imperative}
         Imperative languages, which are also known as procedural languages, treat the input source code as a sequential set of instructions that the computer will run.
         They are also characteristic in that the program's state changes due to the passing of time \autocite{normarkOverviewFourMain}.
         Imperative programming is what most programmers learn first, because thinking of code as a set of instructions that operate on state is a simple concept to grasp.

         Most programming languages offer an imperative approach, and you've most likely used one at some point.
         A few examples of imperative languages are: C, Python, and JavaScript.

         \subsubsection{Example}
         \lstinputlisting[
            language=C,
            firstline=7,
            caption={Imperative code in C},
         label=ex:imperative]
         {examples/chapter1/imperative.c}

         The above example in C shows how an imperative style language works.
         The program executes each line sequentially, and the program's state is modified as it runs.

         \subsection{Object-Oriented}
         Object-oriented languages organize data and methods into 'objects' which is called ``encapsulation''.
         Objects interact with each other through methods that they list publicly to each other, and they are organized in hierarchies of inheritance \autocite{normarkOverviewFourMain}.
         These restrictions on interaction and inheritance allow the programmer to hide away details from how the code actually works.
         As a result, the designer provides methods that perform actions with observable and reasonable side effects.

         Object-oriented languages are in major use today, and they are the primary choice of language for many software projects.
         Some examples of languages that use an object-oriented approach are: C++, Python, and Java.

         \subsubsection{Example}
         % TODO Explain listing
         \lstinputlisting[
            language=Python,
            caption={Object-oriented code in Python},
         label=ex:oop]
         {examples/chapter1/oop.py}

         This example shows a simple object that has both a data member and a method.
         On line 7, it begins running in an imperative style, but it also uses an object oriented approach to control the flow of the code.
         On line 7, an instance of "HelloObject" is made and stored in \textit{a}, and the "hello" method is called upon a.

         \subsection{Functional}
         This paradigm treats code as a series of mathematical equations that are evaluated at run time.
         Functional languages treat data as immutable too, so the program's state cannot be modified at runtime as in the other paradigms \autocite{normarkOverviewFourMain}.
         Functions are also treated like data, and they can be passed as arguments to other functions.

         This approach produces code that is very safe to use, but it can take a much longer amount of time to write.
         It also produces code that is thread-safe by nature, since the resulting program does not update state as it progresses.

         Functional languages are less likely to be used compared to the other two paradigms.
         This is due to the fact that it usually takes more time to develop in a functional language.
         Examples of functional languages include: Haskell, Lisp, and JavaScript\footnotemark.

         \footnotetext{
            Of these languages, only Haskell is purely functional.
            The other languages support functional styles, but they do not restrict the user into following them.
         }

         \subsubsection{Example}
         \lstinputlisting[
            language=Python,
            caption={Functional code in Python},
         label=ex:functional]
         {examples/chapter1/functional.py}

         The above example is very basic functional code written in Python.
         The first line uses a list comprehension to create a list of numbers, from 0-19.
         The second line ``maps'' a function over these numbers that produces a list of their squares.
         Lastly, line 3 filters out all of the even numbers, leaving only the odd, and the resulting list is printed.

         The code looks similar to the previous examples, but the main difference between this one and the others is that each variable does not change once it is created.
         Notice, on each line, a new variable is declared that uses the value of another to compute its own.
         This is strikingly different from the other two approaches, but it produces code that is much safer to run.

         There are more paradigms than just these three, but these are the most commonly seen ones.

         \section{Language Use Cases}
         % Overview of when certain language are best
         While programming languages are typically designed to be used in a variety of situations, over time they start to develop a target domain.
         You can use a language in any manner you see fit, but they each do have strengths and weaknesses when used for different applications.
         It is useful to know what a language is good for, so that you can use the right tool for each job.
         So, what are some common use cases and languages that are useful for them?

         \subsection{Systems and Low Level}
         Systems require languages that can both operate at a low level and run quickly.
         According to Microsoft, systems differ from applications, because they are tasked with controlling the hardware and providing interfaces for higher level languages \autocite{microsoftPanelSystemsProgramming2014}.
         As a result, a standard library and operating system are not present at this level.
         This means that you do not have access to any facility provided by an operating system, like memory management or a filesystem, and you are required to develop everything you need yourself.
         You do however have full access to the resources of the underlying hardware, which can help a project take advantage of hardware easier.

         \subsection{Data Science}
         The concerns of data science are that a language has good support for matrices and for statistical analysis.
         Historically, the languages that have been used are not as focused on speed as they are on flexibility, but speed is becoming a concern as larger projects get built to handle data science needs.

         Languages that are key to data science are Python, R, SQL, Julia \autocite{MostPopularLanguages}

         Python and R are the most widely used, but they do not prioritize speed as a concern.
         Julia is a more recent language that aims to address this concern, while also keeping the same amount of flexibility as Python and R \autocite{MostPopularLanguages}.

         \subsection{Web}
         Web programming has much different concerns from other domains.
         On the web, software is much more focused on usability and scalability \autocite{siiaSoftwareServiceChanging2004}.
         As a result, preferred languages for the Web domain will allow for rapid prototyping, package integration, and object-oriented capabilities.
         Web programming also deals with a separate front-end, which is what the user sees, and backend, which is what the user does not see.
         This section covers useful backend languages.

         Popular languages in this domain include: PHP, Python, and C\#.

         These languages are great for Web development, because they all share features that allow for efficient, rapid development.
         Each of them has an officially developed package management tool that allows for ease of access in including third-party code in a project.
         All three languages also have great frameworks for Web projects that allow for even easier development of good products.
         \subsection{Extra Considerations}
         Programming languages are often designed to be general purpose, and they don't necessarily have to be used as detailed above.
         They can be applied to realistically any domain that the user sees fit, but take care to keep in mind the main concerns a language's design addresses.
         For example, if you wanted to make a speedy web application, you might be inclined to write the application in C.
         While this is acceptable, the amount of time spent developing the application will be exponentially higher than if you had begun the project with a language like Ruby.
         The software you write may also not be portable if you took advantage of system level APIs while writing the code.
         
   \chapter{Challenging Yourself}
   \label{chap:challenge}
      % Programming challenges and things like Project Euler or LeetCode
      Many of the problems a programmer faces are already solved, and it is useful to know how to recognize and solve some of the simpler ones.
      That being said, the examples in this chapter will likely difficult if you have not seen them before, but once you have solved them, they will become trivial for you in the future.
      This chapter will also focus on taking functional approaches to the problems.
      Functional programming is much more difficult to think about than imperative styles, and typically a programmer who can write functional style code can translate it to imperative code if needed.

      \section{Math and Simple Algorithms}
         \subsection{Largest Prime Factor}
         % Project Euler #3
         Prime numbers are an idea that show up quite a bit in modern computing.
         They are the foundation of cryptography, and finding prime numbers with a computer can take a long time.
         That being said, this example will supply a solution to quickly solving for smaller prime numbers in the order of less than 1 million.

         \subsubsection{The Problem}
         Given a number \textit{n}, find the sum of all prime numbers from [2,\textit{n}] in under a second.
         \textit{n} will be less than 1,000,000.

         \subsubsection{The Algorithm}
         The typical way to solve for primality of \textit{n} is to modulus it with every number preceding it and verify if any result produces 0.
         This is a very slow way to solve this problem, and in order to solve it more quickly, we can leverage an algorithm from an ancient Greek mathematician: the \textit{sieve of Eratosthenes}.

         % Include some kind of graphic here
         According to Sedgewick, the sieve works on an array of numbers that get marked if they are composite, and it starts at 2, working up until $\sqrt{n}$.
         Each number, \textit{i}, starting at \textit{$i^2$}, will be marked as composite, until the limit is reached.
         Then, \textit{i} will advance to the next unmarked number, and will continue until the limit.
         At the end, all unmarked numbers are prime \autocite{sedgewickAlgorithms1992}.

         See below, in Listing \ref{sieve} for an example of the sieve in Python.
         \lstinputlisting[
            language=Python,
            firstline=2,
            lastline=23,
            caption={A simple sieve that adds up the resulting primes},
         label=sieve]
         {examples/chapter2/sieve.py}

         The example in Listing \ref{sieve} uses an array of bools with the positions representing each number.
         A value of 'true' indicates that the number is prime, and each number is initially set to 'true'.
         Once this list is created, it is looped over starting from the first prime number, 2, until i reaches $\sqrt{n}$.
         At this point, on line 20, the indices are enumerated alongside the primalities, and the composites are filtered out.
         Then, the primes are summed and returned from the function.

         \subsection{Odd Fibonacci Numbers}
         % Free Code Camp Intermediate JS A&S 'Sum All Odd Fibonacci Numbers'
         This problem comes from FreeCodeCamp's \textit{Intermediate Algorithm Scripting} course, and it functions similarly to the last problem \autocite{freecodecampLearnIntermediateAlgorithm}.
         The structure requires us to slightly revise an existing algorithm to solve a different problem.

         \subsubsection{The Problem}
         ``Given a positive integer, \textit{num}, find the sum of all odd Fibonacci numbers that are less than or equal to \textit{num}.''

         \subsubsection{The Algorithm}
         This problem requires the programmer to use a subset of the Fibonacci sequence in order to find the result.
         A naïve solution would be to generate a list of all Fibonacci numbers less than \textit{num} and filter out the odd numbers.
         A better approach is to accumulate the odd numbers as you generate all Fibonacci numbers less than \textit{num}.
         The below example in Listing \ref{fibNums} shows an example of the second algorithm in Javascript.

         \lstinputlisting[
            language=JavaScript,
            caption={Summing Odd Fibonacci Numbers},
         label=fibNums]
         {examples/chapter2/oddFibNums.js}

         The Fibonacci sequence is a numerical sequence where each consecutive element is found by summing the previous two elements \autocite{parshallFibonacciSequence}.
         The first two elements are 1 and 1, respectively, so the sequence begins as such: 1,1,2,3,5,8\ldots.
         Listing \ref{fibNums} uses an iterative algorithm that accumulates the odd numbered Fibonacci numbers into \lstinline!result!.
         \lstinline!p! and \lstinline!q! represent the previous two members of the sequence.
         This setup is effective, because the work of summing the odd numbers can be done while generating the sequence itself.

   \chapter{Practical Programming}
   \label{chap:practical}
      % Get some ideas from Al Sweisgart's 'Automate the Boring Stuff'
      In this chapter, you will be guided through programming in a useful manner.
      The example in this chapter details a useful and prevalent design pattern, basic database usage, and a simple construction of a command line interface.

      \section{Command Line Contact Book}
      Contact applications are ubiquitous amongst our devices, but there are not many for command line use.
      A contact application is a good example of storing data in a meaningful way and for making sure that it can be retrieved easily too.
      This example will detail the use of a SQLite\footnotemark database and of a model-view-controller design pattern.
      The idea for this project comes from Shopeju at RealPython.org \autocite{shopeju13ProjectIdeas}.

      \footnotetext{
         For more information about SQLite, see the official documentation at \url{https://sqlite.org/index.html}.
         This guide does not assume knowledge about SQL and will attempt to explain as much as is necessary.
      }

      \subsection{Architecture}
      As mentioned previously, this design will use a model-view-controller, or MVC, pattern.
      According to Hernandez, MVC is an object-oriented architectural design pattern for a software project that separates concerns out into three layers: model, view, and controller.
      The model layer contains objects that contain the actual logic of the system.
      The view layer is what is shown to the user, and it contains objects that represent the current state of models in the system.
      Lastly, the controller layer handles passing data between the model and view layers.
      The controller layer is also responsible for controlling how data is displayed \autocite{hernandezModelViewController2021}.

      Using this design pattern allows us to separate out the contact data from the presentation of it, so we can build an interface in a more generic way.
      Another benefit of using this pattern is that changing the user interface is trivial; a change is only required in the view layer.
      One downside of this design is that writing the code becomes a more complex task, but it seems less complex the more familiar you get with the architecture.

      \subsection{Implementation}
      To begin with the implementation, let's take a look at the model layer code.

      \subsubsection{Model Layer}
      \lstinputlisting[
         language=Python,
         firstline=1,
         lastline=41,
         caption={Contact Book model layer}
      label=contactModel]
      {examples/chapter3/contacts/model.py}

      The first two methods, \lstinline!init! and \lstinline!loadBook!, are basic and handle the creation of a database instance to use.
      \lstinline!createBook! on line 21 is where the database operations actually start to occur.
      This method creates a SQL statement on lines 26-31 that creates a new table in our database.
      The table, identified by the name ``contacts'' contains fields that record the each contact's name, phone number, address, and email.
      There is also a field \textbf{id} that is used to uniquely identify each contact in the database.
      Look closely at the constraints provided for \textbf{name} and \textbf{phone}.
      Both fields have a constraint, \textit{NOT NULL}.
      The constraint \textit{NOT NULL} requires that the fields contain an actual value rather than \textit{NULL}, which is SQL's way of representing ``unknown'' \autocite{SQLiteSyntaxColumnconstraint}.
      Now that we've taken a look at the model layer in detail, let's take a look at the view layer to see how the user can interact with our program.

      \subsubsection{View Layer}
      The view layer handles all of the user input and output, so the code for it is rather simple.
      Let's start by taking a look at the \lstinline!__init__! routine.

      \lstinputlisting[
         language=Python,
         firstline=1,
         lastline=16,
         caption={View layer init routine},
      label=viewInit]
      {examples/chapter3/contacts/view.py}

      Python contains a module \lstinline!argparse! that helps to create command line applications.
      Since this example uses a command line interface, this will help us to create options that allow the user to manipulate the contact book's entries..
      For example,  on line 9, we add an optional argument specified by either \textit{-a} or \textit{--add} that allows the user to enter a new contact into the book.
      Similar actions can be seen on lines 11 and 13, where options are added to delete or update entries.
      At the end of this function, the arguments are parsed from the command line when the program is run, and stored for later use.
      Now, we'll see some examples of functions that help enforce the MVC model.

      \lstinputlisting[
         language=Python,
         firstline=22,
         lastline=39,
         caption={More View Layer Routines}
      label=viewRoutines]
      {examples/chapter3/contacts/view.py}

      In the MVC pattern, the view layer is responsible for all user input and output handling.
      The layer does not need to worry about the validity of input, but it does need to worry about getting it.
      The methods \lstinline!getCmd! and \lstinline!getInput! are examples of this pattern, as both of them return a form of user input.
      Input comes either from the user's keyboard or from command line options.
      Finally, \lstinline!show! handles all output to the user.
      This method is very simple, but it shows the power of using the MVC pattern.
      If you were to create a new view layer class in a different setting like the Web, you could implement a show method in the new class and then leave the rest of the code unmodified.
      Restricting input and output to a certain layer separates out concerns of parts of the code in an efficient way.

      Lastly, we will explore the controller layer, which handles passing of data between the view layer and model layer.

      \subsubsection{Controller Layer}
      The controller layer can be thought of as the ``brains'' of the model.
      All logic and input validity are handled by this layer, which might seem counterintuitive at first.
      As was mentioned previously, MVC does add complexity to a rather simple program, but it does allow for a program to be rewritten and managed flexibly.
      Starting off, look at the \lstinline!__init__! routine of the class.
      
      \lstinputlisting[
         language=Python,
         firstline=4,
         lastline=21,
         caption={Controller init routine}
      label=controllerInit]
      {examples/chapter3/contacts/controller.py}

      The controller needs instances of both the view and model layer to use.
      Lines 3 and 4 create these instances for later use.
      The next method of interest is \lstinline!run!, which is what the main program will call when it wants to hand control over to the controller.
      It loads the database into the model, gets the input command, and decides which action to perform.

      \lstinputlisting[
         language=Python,
         firstline=23,
         lastline=38,
         caption={Controller Adding a New Contact},
      label=controllerAdd]
      {examples/chapter3/contacts/controller.py}

      Adding a user to the contact book is performed by \lstinline!_add!, and it shows how simple the controller layer can actually be.
      Starting off on lines 2-5, strings to print to the user are created.
      Since the controller layer should not handle any input or output, it calls the \lstinline!getInput! method of the view layer with each string.
      The controller also handles the logic of determining if the required fields are valid or not on lines 8, 9, 11, and 12.
      Finally, once the input is validated, the new contact information is passed to the model in order to be added to the database.

      The other methods for deleting and updating are similar and only require a change of the input string and the invoked method of the model layer.
   \chapter{Professional Development}
   \label{chap:prof_devel}
      % Ways to improve your programming at a professional level
      % Include example using an API
      Solid, effective programming can lead to a good career in the computing industry.
      Programming is a skill in high demand that can lead to many different high paying careers (see Table \ref*{table:jobs}).
      Learning to develop yourself professionally requires learning about the tools that are available to you, as well as learning programming.
      In this chapter, we will cover API usage with a fun, RESTful API, basic security, and some information on current technology.
      For example code, please refer to \url{https://github.com/evanrh/programmers-guide/tree/main/examples/chapter4}.
      \begin{table}[H]
         \csvreader[
            respect all,
            tabular=|c|c|c|,
            table head=\hline \bfseries{Job} & \bfseries{Required Degree} & \bfseries{Median Salary} \\\hline,
            late after last line=\\\hline
         ]{salaries.csv}{}{
            \csvcoli & \csvcolii & \csvcoliii
         }
         \caption{
            Median salaries of jobs requiring programming skills in 2019, acquired from Malvik at Rasmussen \autocite{malvikProgrammingCareersCoding}.
         }
         \label{table:jobs}
      \end{table}

      \section{Focusing on Security}
      Application security and security by design are becoming more important by the day.
      In 2020 alone, ``ransomware surged by 150\%,'' and that amount is only continuing to grow by the day \autocite{muncasterRansomwareAttacksSoared2021}.
      These types of attacks typically take advantage of people by means of phishing, but they also can leverage poorly written applications.
      In this section, we will explore a very simple example of an application developed with bad security in mind, and how you can easily get around a simple PIN mechanism.

      \subsection{Background and Challenge}
      In order to follow along with this challenge, please download the 'password\_server.py' file from \url{https://github.com/evanrh/programmers-guide/tree/main/examples/chapter4}
      The idea for this example came from level 25 on OverTheWire.org in their 'Bandit' category \autocite{overthewireOverTheWireLevelGoal}.
      A brute force attack is a basic type of cyber attack that uses many repeating, successive attempts of passwords or other forms of authentication in order to get into a system \autocite{universityGrowingCybersecurityThreats2019}.
      These are very common amongst all forms of hackers, so it is important that an application keep them in mind.
      The server application you just downloaded does not perform any complex action, but it is still a great example of an unsecure system.
      Let's take a look at how it works and explain why it is not secure.

      \lstinputlisting[
         language=Python,
         caption={The unsecure server application},
      label=unsecureServer]
      {examples/chapter4/password_server.py}

      This very basic application takes a string and compares it to a known password and PIN combination.
      It will then either send the client a message saying ``Wrong!'' if the combination is wrong, or ``Correct!'' with a new password as the output.
      The logic of determining whether or not the password and PIN combination is correct occurs on line 28.
      There isn't anything seemingly wrong with this logic, but it does have one big issue: there is no lockout for entering a wrong password too many times.

      Since there is no lockout mechanism, a client can attempt as many password and PIN combinations as they want to.
      There are also a finite number of PIN numbers that can be tried, since the password is known.
      The PIN is a 4 digit number, so there are only 10000 possible PINs to try, which is a very small number.
      It is a trivial to overcome this security as a result.
      Now, let's take a look at a client program that can exploit this vulnerability.
      \subsection{Breaking the Security}

      \lstinputlisting[
         language=Python,
         firstline=1,
         lastline=34,
         caption={Brute Forcing the Unsecure Server},
      label=bfClient]
      {examples/chapter4/client.py}

      Beginning on line 4, our client object will open a connection to the specified server and capture its welcome message.
      Then, on line 14, \lstinline!try_pin! attempts a pin combination with the password, and checks the message from the server to see if it worked.
      It returns whether or not the combination did work.
      Now, let's look at \lstinline!main! on line 25.

      A client is created on line 26 with the address and port of a locally running server.
      It also passes in the known password to the client object.
      On line 28, a loop begins that will create all of the PINs between 0000 and 9999.
      This loop will continue until the \lstinline!try_pin! method returns ``True.''
      Once it does, the client will print the correct PIN and stop.
      Otherwise, it prints out ``Wrong PIN:'' and the wrong PIN.
      Then, it continues to the next PIN.
      \section{API Usage}
      APIs or 'Application Programming Interfaces' are publicly exposed methods for accessing someone else's system.
      REST, which stands for 'REpresentational State Transfer' is a design pattern that allows responses between a client and server to remain stateless and consistently defined \autocite{hallettPokeAPI}.
      The API being used for this chapter is called 'PokeAPI', and it is used to provide a programmatic interface to information regarding Pokémon.
      While not inherently useful on its own for our purposes, this API will help show you how many APIs across the web structure themselves.
      Knowledge of one RESTful API will lead to easier access to any others you come across while coding.

      PokeAPI provides varying information about Pokémon and the games and media they appear in.
      Our example is going to show how you can get information about a single Pokémon using Python's \lstinline!requests! library.
      This library will enable us to get the data easily and create a simple client for grabbing the information we want.

      \lstinputlisting[
         language=Python,
         caption={Small PokeAPI Client},
      label=apiClient]
      {examples/chapter4/api_client.py}

      Listing \ref{apiClient} shows a very basic script to grab data related to the Pokémon Pikachu.
      The \lstinline!query! method on line 5 uses the \lstinline!requests! library mentioned previously to open an HTTP connection to PokeAPI.
      It uses a GET method, as indicated by the \lstinline!requests.get()! on line 8, and it checks to see if the response was good.
      HTTP uses response codes to indicate the result of an interaction with a server, and a response code of 200 indicates a successful interaction \autocite{mozillaHTTPResponseStatus}.
      Upon a successful request, the response is returned to the calling code as a JSON object.
      
      Below the \lstinline!query! method is where the decoding of the response occurs.
      We are interested in getting the Pokemon's name, a short description, and a URL for a sprite image.
      According to the API documentation, the response at the \textit{pokemon-species} endpoint we are using returns an object that contains fields for a name, flavor text, varieties, and some other fields we are not interested in \autocite{hallettPokeAPI}.
      Getting the name from this object is straightforward, we can access it by using the index, 'name' on the \textit{pikachu} variable, as seen on line 23.
      The other information requires reading the documentation for the returned object a little further.

      The returned object contains a field, \textit{flavor\_text\_entries} that is a list of flavor text that this Pokemon has had across all of the games.
      We can retrieve flavor text from this list, but we need to filter it first.
      This list contains flavor text from all languages from every game that the Pokemon appears in.
      Each entry contains a \textit{language} field, which in turn has a \textit{name} field that denotes the actual language of the entry.
      We can use this to filter the entries, which is the action being performed on line 16 to \textit{desc\_links}.

      Finally, we can get the sprite link from the returned Pokemon.
      The object we currently have does not have any direct links to sprite data, but it does have a list of links to other endpoints that do.
      The \textit{varieties} field of \textit{pikachu} has this list, and we'll use the first one at index 0 for this case.
      This field has a field \textit{pokemon} with a subfield \textit{url} that contains the URL we are interested in.
      It points to the \textit{pokemon} endpoint, which has sprite data for our Pokemon.
      On lines 20 and 21, we perform another query to this new endpoint, and grab the sprite data from the newly returned object.

      Listing \ref{apiClient} shows basic usage of an API endpoint, which would be needed to build a more complex application.
      The flow of this example program is very similar to larger scale applications, and it could be applied to one.
      The most important part of writing applications that deal with APIs is understanding the documentation well.
      This helps to ensure that you know how to perform actions in an efficient manner, and it helps in knowing the scope of the API as well.

      \section{Current Technology and Practices}
      Software development has taken to a new domain in the past 20 years.
      Most applications now are being developed to run as web applications or 'software-as-a-service' (SAAS) in cloud based environments currently \autocite{WhatCloudComputing}.
      As a result of this shift, applications require a special set of considerations to be made, so that they can scale and serve users properly.

      The typical guideline for this is known as the \textit{12 Factor App\footnotemark}, which separates out the concerns of an application from its runtime environment \autocite{wigginsTwelveFactorApp2017}.
      Using this as a basis allows for a small, scalable application that can be deployed on almost any machine.
      Let's take a look at some of the most important tenets from the specification.
      \footnotetext{
         An HTML version of the 12 Factor App spec can be found at \url{https://12factor.net}.
      }

      \subsection{Tenet II: Depedencies}
      ``Explicitly declare and isolate dependencies \autocite{wigginsTwelveFactorApp2017}.''
      Dependency issues occur more in larger applications than small ones, but it is always important to explicitly state what an application needs to run.
      As development teams get larger, this is even more so important, because everyone does not develop in the same environment.
      It also helps for automating releases onto production machines, because you can automate the installation of dependencies if they are declared beforehand.

      \subsection{Tenet III: Config}
      ``Store config in the environment \autocite{wigginsTwelveFactorApp2017}.''
      Configuration can change over time, and it can vary across different machines.
      Newer developers tend to store configuration in the source code, which is not only inflexible, but it is also unsecure.
      Keeping it separate from the code ensures that the application can run on any machine with any credentials or setup.

      \subsection{Tenet X: Dev/prod parity}
      ``Keep development, staging, and production as similar as possible \autocite{wigginsTwelveFactorApp2017}.''
      Keeping the development and production environments as similar as possible ensures the maximum amount of compatibility between them.
      Developers can often forget to add packages to configurations or might not run their code on the same machine as production.
      This can lead to issues down the line that can be hard to track down.

      \section{Summary}
      The \textit{12 Factor App} is a great set of guidelines for building a webapp, but it is not necessarily great for all application use cases.
      Building applications for other domains may required configuration to be built into the code.
      Always take care to assess the needs of your software before deciding on the implementation.

      \chapter{Final Thoughts}
      Programming is a skillset that you should always be growing.
      New technology gets created frequently, so it is important to keep up with the trends.
      This guide should be a good place to get started, but you should not consider it the only resource.

      By now, you should have some exposure to critical thinking with algorithms, programming pragmatically, and what current technology you can leverage in your software.
      This is a good overview on what a more experienced programmer should be familiar with, and you should have a good amount of knowledge to continue learning on your own.
      Thank you for taking the time to read this guide.
      I hope it has helped you to sharpen your programming skills to a satisfatory point.

   \appendix
   \begin{appendices}
   \chapter{Running Example Code}
   A minimal Python installation can be obtained from \url{https://www.python.org/downloads/}.
   Once installed, you can either run the programs by opening a terminal and running, 'python file.py'.
   Be sure to replace ``file.py'' by the name of the program you are attempting to run.
\newpage
\phantomsection
\printbibliography[title={Works Cited},heading=bibintoc]
   \end{appendices}
\end{document}
